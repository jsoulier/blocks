#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct t_player_position
{
    float3 u_player_position;
};

struct t_shadow_vector
{
    float3 u_shadow_vector;
};

constant spvUnsafeArray<float3, 6> _243 = spvUnsafeArray<float3, 6>({ float3(0.0, 0.0, 1.0), float3(0.0, 0.0, -1.0), float3(1.0, 0.0, 0.0), float3(-1.0, 0.0, 0.0), float3(0.0, 1.0, 0.0), float3(0.0, -1.0, 0.0) });

struct main0_out
{
    float4 o_color [[color(0)]];
};

struct main0_in
{
    float3 i_position [[user(locn0)]];
    float3 i_uv [[user(locn1)]];
    float3 i_normal [[user(locn2), flat]];
    float4 i_shadow_position [[user(locn3)]];
    uint i_shadowed [[user(locn4)]];
    uint i_occluded [[user(locn5)]];
    float i_fog [[user(locn6)]];
    float2 i_fragment [[user(locn7)]];
};

static inline __attribute__((always_inline))
float3 get_sky(float y)
{
    return mix(float3(0.699999988079071044921875, 0.89999997615814208984375, 1.0), float3(0.300000011920928955078125, 0.60000002384185791015625, 0.89999997615814208984375), float3(fast::clamp(y, 0.0, 0.800000011920928955078125)));
}

static inline __attribute__((always_inline))
float4 get_color(texture2d_array<float> atlas, sampler atlasSmplr, texture2d<float> shadowmap, sampler shadowmapSmplr, float3 position, float3 uv, float3 normal, float3 player_position, float3 shadow_position, float3 shadow_vector, bool shadowed, bool occluded, float fog, float ssao, float alpha)
{
    float3 shadow_uv;
    shadow_uv.x = (shadow_position.x * 0.5) + 0.5;
    shadow_uv.y = 1.0 - ((shadow_position.y * 0.5) + 0.5);
    shadow_uv.z = shadow_position.z;
    float ao = ssao * 0.4000000059604644775390625;
    float ambient = 0.20000000298023223876953125;
    float directional = 0.0;
    float angle = dot(normal, -shadow_vector);
    float depth = shadow_uv.z - 0.001000000047497451305389404296875;
    bool _83 = !shadowed;
    bool _117;
    if (!_83)
    {
        bool _88 = angle > 0.0;
        bool _116;
        if (_88)
        {
            bool _95 = all(shadow_uv <= float3(0.0));
            bool _103;
            if (!_95)
            {
                _103 = all(shadow_uv >= float3(1.0));
            }
            else
            {
                _103 = _95;
            }
            bool _115;
            if (!_103)
            {
                _115 = depth < shadowmap.sample(shadowmapSmplr, shadow_uv.xy).x;
            }
            else
            {
                _115 = _103;
            }
            _116 = _115;
        }
        else
        {
            _116 = _88;
        }
        _117 = _116;
    }
    else
    {
        _117 = _83;
    }
    if (_117)
    {
        directional = fast::max(angle, 0.0) * 1.2000000476837158203125;
    }
    if (!occluded)
    {
        ao = 0.699999988079071044921875;
    }
    float4 color = atlas.sample(atlasSmplr, uv.xy, uint(rint(uv.z)));
    color.w = fast::clamp(color.w + alpha, 0.0, 1.0);
    float light = (ao + ambient) + directional;
    float dy = position.y - player_position.y;
    float dx = distance(position.xz, player_position.xz);
    float pitch = precise::atan2(dy, dx);
    float4 sky = float4(get_sky(pitch), 1.0);
    float4 composite = float4(color.xyz * light, color.w);
    return mix(composite, sky, float4(fog));
}

fragment main0_out main0(main0_in in [[stage_in]], constant t_shadow_vector& _209 [[buffer(0)]], constant t_player_position& _192 [[buffer(1)]], texture2d_array<float> s_atlas [[texture(0)]], texture2d<float> s_shadowmap [[texture(1)]], texture2d<float> s_position [[texture(2)]], sampler s_atlasSmplr [[sampler(0)]], sampler s_shadowmapSmplr [[sampler(1)]], sampler s_positionSmplr [[sampler(2)]])
{
    main0_out out = {};
    out.o_color = get_color(s_atlas, s_atlasSmplr, s_shadowmap, s_shadowmapSmplr, in.i_position, in.i_uv, in.i_normal, _192.u_player_position, in.i_shadow_position.xyz / float3(in.i_shadow_position.w), _209.u_shadow_vector, in.i_shadowed != 0u, in.i_occluded != 0u, in.i_fog, 1.0, (in.i_position.y - s_position.sample(s_positionSmplr, in.i_fragment).y) / 20.0);
    return out;
}

