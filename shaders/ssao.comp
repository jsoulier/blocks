#include "voxel.hlsl"

Texture2D<uint> voxelTexture : register(t0, space0);
Texture2D<float3> positionTexture : register(t1, space0);
[[vk::image_format("r8")]]
RWTexture2D<float> ssaoTexture : register(u0, space1);

static const float kBias = 0.01f;
static const int kKernel = 1;

bool IsOccluded(uint2 id, uint direction, float3 position)
{
    uint voxel = voxelTexture[id].x;
    if (!VoxelGetOcclusion(voxel))
    {
        return false;
    }
    float3 neighbor = positionTexture[id].xyz;
    float offsets[6];
    offsets[0] = neighbor.z - position.z;
    offsets[1] = position.z - neighbor.z;
    offsets[2] = neighbor.x - position.x;
    offsets[3] = position.x - neighbor.x;
    offsets[4] = neighbor.y - position.y;
    offsets[5] = position.y - neighbor.y;
    return offsets[direction] > kBias;
}

[numthreads(8, 8, 1)]
void main(uint3 threadID : SV_DispatchThreadID)
{
    uint width;
    uint height;
    ssaoTexture.GetDimensions(width, height);
    if (threadID.x >= width || threadID.y >= height)
    {
        return;
    }
    ssaoTexture[threadID.xy] = 1.0f;
    uint voxel = voxelTexture[threadID.xy];
    if (!VoxelGetOcclusion(voxel))
    {
        return;
    }
    uint direction = VoxelGetDirection(voxel);
    float3 position = positionTexture[threadID.xy];
    float ssao = 0.0f;
    for (int x = -kKernel; x <= kKernel; x++)
    for (int y = -kKernel; y <= kKernel; y++)
    {
        uint2 id = threadID.xy + 1.0f * float2(x, y);
        if (id.x < 0 || id.y < 0 || id.x >= width || id.y >= height)
        {
            continue;
        }
        ssao += float(IsOccluded(id, direction, position));
    }
    int kernel = kKernel * 2 + 1;
    kernel *= kernel;
    kernel -= 1;
    ssaoTexture[threadID.xy] = 1.0 - (ssao / float(kKernel));
}
